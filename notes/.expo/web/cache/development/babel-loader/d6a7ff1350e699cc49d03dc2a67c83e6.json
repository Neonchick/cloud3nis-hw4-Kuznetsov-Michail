{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = _regeneratorRuntime.mark(doFetch);\n\nvar END_POINT = 'http://localhost:3000';\nexport function doFetch(_ref) {\n  var method, url, data, fullPath, response;\n  return _regeneratorRuntime.wrap(function doFetch$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          method = _ref.method, url = _ref.url, data = _ref.data;\n          fullPath = END_POINT + url;\n          _context.prev = 2;\n          _context.next = 5;\n          return fetch(fullPath, {\n            method: method\n          });\n\n        case 5:\n          response = _context.sent;\n          _context.next = 8;\n          return response.json();\n\n        case 8:\n          response = _context.sent;\n          return _context.abrupt(\"return\", {\n            data: response\n          });\n\n        case 12:\n          _context.prev = 12;\n          _context.t0 = _context[\"catch\"](2);\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 12]]);\n}","map":{"version":3,"sources":["C:/source/HSE/Cross-PlatformApps/cloud3nis-hw4-Kuznetsov-Michail/notes/src/lib/do-fetch.js"],"names":["doFetch","END_POINT","method","url","data","fullPath","fetch","response","json"],"mappings":";;uCAEiBA,O;;AAFjB,IAAMC,SAAS,GAAG,uBAAlB;AAEA,OAAO,SAAUD,OAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACHE,UAAAA,MADG,QACHA,MADG,EAEHC,GAFG,QAEHA,GAFG,EAGHC,IAHG,QAGHA,IAHG;AAMGC,UAAAA,QANH,GAMcJ,SAAS,GAAGE,GAN1B;AAAA;AAAA;AASgB,iBAAMG,KAAK,CAACD,QAAD,EAAW;AACjCH,YAAAA,MAAM,EAAEA;AADyB,WAAX,CAAX;;AAThB;AASKK,UAAAA,QATL;AAAA;AAaY,iBAAMA,QAAQ,CAACC,IAAT,EAAN;;AAbZ;AAaCD,UAAAA,QAbD;AAAA,2CAeQ;AAACH,YAAAA,IAAI,EAAEG;AAAP,WAfR;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["const END_POINT = 'http://localhost:3000';\r\n\r\nexport function* doFetch({\r\n    method,\r\n    url,\r\n    data,\r\n                         })\r\n{\r\n    const fullPath = END_POINT + url;\r\n\r\n    try {\r\n        let response = yield fetch(fullPath, {\r\n            method: method,\r\n            \r\n        });\r\n        response = yield response.json()\r\n\r\n        return {data: response};\r\n    } catch (error) {\r\n        return error;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}